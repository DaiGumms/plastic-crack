# GitHub Copilot Instructions for Plastic Crack Project

## Project Overview

**Plastic Crack** is a comprehensive model/miniature collection management application with web, mobile, and backend components. The main goal is to provide hobbyists with tools to catalog, track, and manage their plastic model collections with features like photo management, painting progress tracking, and price monitoring.

### Core Mission
Build a production-ready MVP that enables users to:
- Catalog and organize their model collections
- Track painting progress and completion status
- Upload and manage photos of their models
- Monitor prices and set alerts
- Share collections with the community

## Architecture Overview

### Multi-Platform Structure
```
plastic-crack/
├── backend/          # Node.js/Express API with PostgreSQL
├── frontend/         # React web application (Vite + TypeScript)
├── mobile/          # React Native mobile app
├── shared/          # Shared types and utilities
├── docs/           # Documentation
└── scripts/        # Development and deployment scripts
```

### Technology Stack
- **Backend**: Node.js, Express, TypeScript, Prisma, PostgreSQL, Redis
- **Frontend**: React, Vite, TypeScript, Tailwind CSS
- **Mobile**: React Native, Expo
- **Database**: PostgreSQL with Prisma ORM
- **Authentication**: JWT with role-based authorization
- **Testing**: Jest, React Testing Library

## Development Guidelines

### 1. Code Quality Standards

#### TypeScript Best Practices
- Always use strict TypeScript configuration
- Define proper interfaces for all data structures
- Use generic types where appropriate
- Avoid `any` type - use specific types or `unknown`
- Implement proper error handling with typed exceptions

#### Code Style
- Use ESLint and Prettier configurations provided in the project
- Follow consistent naming conventions:
  - `camelCase` for variables and functions
  - `PascalCase` for components and types
  - `UPPER_SNAKE_CASE` for constants
- Write self-documenting code with clear variable names
- Add JSDoc comments for complex functions and APIs

### 2. File Organization

#### Backend Structure
```
backend/src/
├── config/          # Configuration files
├── middleware/      # Express middleware
├── routes/         # API route handlers
├── services/       # Business logic
├── types/          # TypeScript type definitions
├── utils/          # Utility functions
├── __tests__/      # Test files
└── generated/      # Generated code (Prisma client)
```

#### Frontend Structure
```
frontend/src/
├── components/     # Reusable React components
├── pages/         # Page components
├── hooks/         # Custom React hooks
├── services/      # API client functions
├── store/         # State management
├── types/         # TypeScript types
└── utils/         # Utility functions
```

### 3. Database and API Guidelines

#### Prisma Best Practices
- Always create migrations for schema changes: `npx prisma migrate dev`
- Use descriptive migration names
- Include proper relationships and constraints
- Add indexes for frequently queried fields
- Use enums for predefined values

#### API Design
- Follow RESTful conventions
- Use proper HTTP status codes
- Implement consistent error response format
- Add input validation with express-validator
- Include proper authentication/authorization middleware
- Document APIs with JSDoc/Swagger comments

#### Example API Route Structure
```typescript
router.post('/collections',
  authenticateToken,
  requirePermission('collection:write'),
  [
    body('name').isLength({ min: 1, max: 100 }),
    body('description').optional().isLength({ max: 500 })
  ],
  async (req: AuthenticatedRequest, res: Response) => {
    // Implementation
  }
);
```

### 4. Authorization System

#### Role Hierarchy
1. **USER**: Basic user permissions
2. **MODERATOR**: Content moderation capabilities
3. **ADMIN**: Administrative access
4. **SUPER_ADMIN**: Full system access

#### Permission Format
Use `resource:action` pattern: `collection:write`, `user:admin`, `system:config`

#### Middleware Usage
```typescript
// Role-based protection
router.delete('/admin/users/:id', authenticateToken, requireAdmin, handler);

// Permission-based protection
router.post('/moderate', authenticateToken, requirePermission('content:moderate'), handler);

// Ownership or admin access
router.put('/users/:id', authenticateToken, requireOwnershipOrAdmin(req => req.params.id), handler);
```

### 5. Testing Standards

#### Test Structure
- **Unit Tests**: Individual functions and components
- **Integration Tests**: API endpoints and database operations
- **E2E Tests**: Complete user workflows

#### Test Naming Convention
```typescript
describe('UserService', () => {
  describe('getUserById', () => {
    it('should return user when valid ID provided', () => {
      // Test implementation
    });
    
    it('should throw error when user not found', () => {
      // Test implementation
    });
  });
});
```

#### Test Requirements
- Maintain 90%+ test coverage
- Test both happy path and error scenarios
- Use proper test isolation and cleanup
- Mock external dependencies appropriately

### 6. Error Handling

#### Backend Error Handling
```typescript
try {
  const result = await SomeService.operation();
  res.json({ success: true, data: result });
} catch (error) {
  console.error('Operation failed:', error);
  res.status(500).json({
    success: false,
    error: { message: 'Internal server error' },
    timestamp: new Date().toISOString()
  });
}
```

#### Frontend Error Handling
- Use error boundaries for component error handling
- Implement proper loading states
- Show user-friendly error messages
- Log errors appropriately for debugging

### 7. State Management

#### Backend State
- Use services for business logic
- Implement proper database transactions
- Use Redis for caching when appropriate
- Maintain stateless API design

#### Frontend State
- Use React hooks for local state
- Implement global state management for shared data
- Use React Query/SWR for server state management
- Minimize state complexity

## Available Services and MCPs

### 1. GitHub MCP
Used for repository management and issue tracking.

#### Common Operations
```typescript
// List issues
mcp_github_list_issues({ owner: 'DaiGumms', repo: 'plastic-crack' })

// Get specific issue
mcp_github_get_issue({ owner: 'DaiGumms', repo: 'plastic-crack', issue_number: 7 })

// Create pull request
mcp_github_create_pull_request({
  owner: 'DaiGumms',
  repo: 'plastic-crack',
  title: 'Feature: Authorization System',
  head: 'feature/auth-system',
  base: 'main'
})
```

### 2. Database Services

#### Prisma Client Usage
```typescript
// Always use transactions for multiple operations
await prisma.$transaction(async (tx) => {
  const user = await tx.user.create({ data: userData });
  await tx.collection.create({ data: { ...collectionData, userId: user.id } });
});

// Use proper error handling
try {
  const user = await prisma.user.findUniqueOrThrow({ where: { id } });
} catch (error) {
  if (error instanceof Prisma.NotFoundError) {
    throw new Error('User not found');
  }
  throw error;
}
```

### 3. File Management

#### Image Upload Handling
- Use multer for file uploads
- Implement proper file validation (type, size)
- Store files in organized directory structure
- Generate unique filenames to prevent conflicts
- Implement file cleanup for deleted resources

### 4. Authentication Services

#### JWT Token Management
```typescript
// Always include role in JWT payload
const token = AuthService.generateToken({
  userId: user.id,
  username: user.username,
  email: user.email,
  role: user.role
});

// Verify and inject user context
const user = await AuthService.getUserById(decoded.userId);
req.user = {
  ...user,
  permissions: getUserPermissions(user.role, user.permissions)
};
```

## Development Workflow

### 1. Issue-Driven Development
- Always work from GitHub issues
- Reference issue numbers in commits
- Follow issue acceptance criteria
- Update issue status as work progresses

### 2. Branch Strategy
- `main`: Production-ready code
- `feature/*`: Feature development branches
- `hotfix/*`: Critical bug fixes
- `release/*`: Release preparation

### 3. Commit Guidelines
```
type(scope): description

feat(auth): implement role-based authorization middleware
fix(api): resolve user profile update validation
docs(readme): add setup instructions
test(user): add comprehensive user service tests
```

### 4. Code Review Process
- All changes require pull requests
- Include comprehensive testing
- Update documentation as needed
- Ensure backward compatibility
- Verify security implications

## Performance Guidelines

### 1. Database Optimization
- Use proper indexes for queries
- Implement pagination for large datasets
- Use database connection pooling
- Monitor query performance
- Use Redis for frequently accessed data

### 2. API Performance
- Implement request/response caching
- Use compression middleware
- Implement rate limiting
- Monitor response times
- Use efficient data serialization

### 3. Frontend Performance
- Implement code splitting
- Use lazy loading for routes
- Optimize bundle size
- Implement proper caching strategies
- Use performance monitoring

## Security Best Practices

### 1. Authentication & Authorization
- Always validate JWT tokens server-side
- Implement proper role-based access control
- Use secure password hashing (bcrypt)
- Implement rate limiting for auth endpoints
- Log security-related events

### 2. Input Validation
- Validate all user inputs
- Use parameterized queries (Prisma handles this)
- Implement proper file upload validation
- Sanitize user-generated content
- Use HTTPS in production

### 3. Data Protection
- Never log sensitive information
- Use environment variables for secrets
- Implement proper error messages (no info leakage)
- Use secure session management
- Implement proper audit logging

## Deployment and Operations

### 1. Environment Configuration
- Use `.env` files for environment-specific config
- Never commit secrets to version control
- Use proper environment validation
- Implement health check endpoints
- Use structured logging

### 2. Monitoring and Logging
```typescript
// Structured logging example
logger.info('User profile updated', {
  userId: user.id,
  changes: updatedFields,
  timestamp: new Date().toISOString()
});
```

### 3. Database Management
- Always backup before migrations
- Test migrations on staging first
- Use Prisma migrate for schema changes
- Monitor database performance
- Implement proper connection management

## Common Patterns and Examples

### 1. Service Layer Pattern
```typescript
export class UserService {
  static async createUser(userData: CreateUserRequest): Promise<User> {
    // Validation
    await this.validateUserData(userData);
    
    // Business logic
    const hashedPassword = await AuthService.hashPassword(userData.password);
    
    // Database operation
    return await prisma.user.create({
      data: { ...userData, passwordHash: hashedPassword }
    });
  }
}
```

### 2. Error Response Format
```typescript
interface ErrorResponse {
  success: false;
  error: {
    message: string;
    code?: string;
    details?: unknown;
  };
  timestamp: string;
}
```

### 3. Success Response Format
```typescript
interface SuccessResponse<T> {
  success: true;
  data: T;
  meta?: {
    pagination?: PaginationInfo;
    total?: number;
  };
}
```

## Continuous Integration

### 1. Test Requirements
- All tests must pass before merge
- Maintain minimum test coverage thresholds
- Include both unit and integration tests
- Test error scenarios thoroughly

### 2. Code Quality Gates
- ESLint must pass without errors
- TypeScript compilation must succeed
- Prettier formatting must be applied
- No security vulnerabilities in dependencies

### 3. Build and Deploy
- Automated testing on all PRs
- Automated deployment on main branch
- Environment-specific configurations
- Rollback procedures for failed deployments

## Documentation Standards

### 1. Code Documentation
- JSDoc for all public APIs
- README files for each major component
- Architecture decision records (ADRs)
- API documentation with examples

### 2. User Documentation
- Setup and installation guides
- Feature documentation with screenshots
- Troubleshooting guides
- FAQ sections

Remember: The goal is building a production-ready application that provides real value to model hobbyists. Always prioritize code quality, security, and user experience in every development decision.
