# GitHub Copilot Instructions for Plastic Crack Project

## Project Overview

**Plastic Crack** is a comprehensive model/miniature collection management application with web, mobile, and backend components. The main goal is to provide hobbyists with tools to catalog, track, and manage their plastic model collections with features like photo management, painting progress tracking, and price monitoring.

### Core Mission
Build a production-ready MVP that enables users to:
- Catalog and organize their model collections
- Track painting progress and completion status
- Upload and manage photos of their models
- Monitor prices and set alerts
- Share collections with the community

## Architecture Overview

### Multi-Platform Structure
```
plastic-crack/
├── backend/          # Node.js/Express API with PostgreSQL
├── frontend/         # React web application (Vite + TypeScript)
├── mobile/          # React Native mobile app
├── shared/          # Shared types and utilities
├── docs/           # Documentation
└── scripts/        # Development and deployment scripts
```

### Technology Stack
- **Backend**: Node.js, Express, TypeScript, Prisma, PostgreSQL, Redis
- **Frontend**: React, Vite, TypeScript, Tailwind CSS
- **Mobile**: React Native, Expo
- **Testing**: Jest, React Testing Library

## Development Guidelines

### 1. Code Quality & Organization
- Use strict TypeScript - avoid `any`, prefer interfaces
- Follow naming: `camelCase` (variables), `PascalCase` (components), `UPPER_SNAKE_CASE` (constants)
- Use ESLint/Prettier configurations
- Add JSDoc for complex functions

### 2. Database & API Best Practices
- Create migrations: `npx prisma migrate dev --name descriptive-name`
- Follow RESTful conventions with proper HTTP status codes
- Use express-validator for input validation
- Include authentication/authorization middleware
- Implement consistent error responses

#### Example API Route Structure
```typescript
router.post('/collections',
  authenticateToken,
  requirePermission('collection:write'),
  [
    body('name').isLength({ min: 1, max: 100 }),
    body('description').optional().isLength({ max: 500 })
  ],
  async (req: AuthenticatedRequest, res: Response) => {
    // Implementation
  }
);
```

### 3. Authorization System
- **Roles**: USER → MODERATOR → ADMIN → SUPER_ADMIN (hierarchical)
- **Permissions**: Use `resource:action` format (e.g., `content:moderate`, `user:admin`)
- **Middleware**: `requireAdmin`, `requirePermission('permission')`, `requireOwnershipOrAdmin()`
- **Implementation**: Always test authorization with different role levels

### 4. Testing Standards
- **Coverage**: Maintain 90%+ test coverage
- **Structure**: Unit tests for functions, integration tests for APIs, E2E for workflows
- **Requirements**: Test happy path and error scenarios, use proper mocking

### 5. Error Handling
- **Backend**: Use try-catch blocks, standardized error response format
- **Frontend**: Implement error boundaries, user-friendly error messages
- **Logging**: Use appropriate log levels (error, warn, info, debug)

#### Frontend Error Handling
- Use error boundaries for component error handling
- Implement proper loading states
- Show user-friendly error messages
- Log errors appropriately for debugging

### 6. State Management
- **Backend**: Stateless API design, use services for business logic, Redis for caching
- **Frontend**: React hooks for local state, React Query for server state

## Key Services and Patterns

### 1. Database Operations
- Use Prisma transactions for multiple operations
- Always handle NotFoundError appropriately
- Include user role in JWT payload and verify permissions

### 2. File Management
- Use multer for uploads with proper validation
- Generate unique filenames and implement cleanup

### 3. Development Workflow
- Work from GitHub issues with referenced commits
- Use branch strategy: `main`, `feature/*`, `hotfix/*`, `release/*`
```
type(scope): description

feat(auth): implement role-based authorization middleware
fix(api): resolve user profile update validation
docs(readme): add setup instructions
test(user): add comprehensive user service tests
```

### 4. Code Review Process
- All changes require pull requests
- Include comprehensive testing
- Update documentation as needed
- Ensure backward compatibility
- Verify security implications

## Performance & Security

### Performance Guidelines
- **Database**: Use indexes, pagination, connection pooling, Redis for caching
- **API**: Implement caching, compression, rate limiting
- **Frontend**: Code splitting, lazy loading, bundle optimization

### Security Best Practices
- **Authentication**: Validate JWT server-side, use bcrypt, implement rate limiting
- **Input Validation**: Validate all inputs, use parameterized queries, sanitize content
- **Data Protection**: No secrets in logs/commits, use HTTPS, implement audit logging

## Deployment & Quality Standards

### Operations
- Use environment variables for configuration and secrets
- Implement health check endpoints and structured logging
- Always backup before migrations, test on staging first

### Code Quality Requirements
- All tests must pass with 90%+ coverage
- ESLint and TypeScript compilation must succeed
- No security vulnerabilities in dependencies
- Follow standardized error/success response formats

### Documentation
- JSDoc for public APIs, README for components
- Setup guides and troubleshooting documentation

## Development Environment

### Terminal Environment
This project uses **PowerShell** as the default terminal environment on Windows. When using the `run_in_terminal` tool, always use PowerShell-compatible syntax.

#### PowerShell Best Practices
- Use semicolons (`;`) instead of `&&` for command chaining
- Use PowerShell-native commands when available
- Handle path separators correctly for Windows
- Use proper PowerShell variable syntax when needed

#### Common Command Patterns
```powershell
# Correct: Change directory and run command
cd backend; npm test

# Correct: Multiple commands
cd backend; npm install; npm run build

# Correct: Conditional execution
if ($LASTEXITCODE -eq 0) { npm run deploy }

# Path handling (use forward slashes or escape backslashes)
cd "C:\Users\Project\backend"
# or
cd C:/Users/Project/backend
```

#### Environment Variables
```powershell
# Set environment variable
$env:NODE_ENV = "development"

# Use environment variable
echo $env:NODE_ENV
```

#### File Operations
```powershell
# Create directory
New-Item -ItemType Directory -Path "uploads/profiles" -Force

# Copy files
Copy-Item "source.txt" "destination.txt"

# Remove files/directories
Remove-Item "temp/" -Recurse -Force
```

## Documentation References

### Project Documentation
The following documentation files are available in the repository:

#### Core Documentation (`/docs/`)
- **`api-specification.md`** - Complete API endpoint documentation
- **`database-design.md`** - Database schema and relationship documentation
- **`deployment-guide.md`** - Production deployment instructions
- **`functional-requirements.md`** - Detailed functional requirements (FR-001 to FR-053)
- **`implementation-strategy.md`** - Development phases and implementation approach
- **`security-documentation.md`** - Security guidelines and best practices
- **`technical-architecture.md`** - System architecture and component overview
- **`authorization-system.md`** - Role-based authorization system documentation
- **`testing-guide.md`** - Testing strategies, setup, and troubleshooting

#### Backend Documentation (`/backend/docs/`)
- **`REDIS_CHANGELOG.md`** - Redis integration changes and updates
- **`REDIS_INTEGRATION.md`** - Redis setup and usage documentation

#### Component READMEs
- **`/backend/README.md`** - Backend setup, development, and API documentation
- **`/frontend/README.md`** - Frontend development setup and component guide
- **`/mobile/README.md`** - React Native mobile app setup and development
- **`/shared/README.md`** - Shared utilities and types documentation

### Documentation Guidelines
When referencing or updating documentation:

1. **Always check existing docs first** - Before implementing features, review relevant documentation
2. **Update docs with changes** - Any new features or changes must be documented
3. **Link related docs** - Cross-reference related documentation sections
4. **Use consistent formatting** - Follow the established markdown patterns
5. **Include examples** - Provide code examples for complex features

### Quick Reference Links
For common development tasks, reference these key documents:

- **Setting up the project**: `/backend/README.md`, `/frontend/README.md`
- **Database changes**: `/docs/database-design.md`
- **API development**: `/docs/api-specification.md`
- **Authorization**: `/docs/authorization-system.md`
- **Testing**: `/docs/testing-guide.md`
- **Deployment**: `/docs/deployment-guide.md`

### Documentation Standards
- Use clear, descriptive headings
- Include code examples with proper syntax highlighting
- Add table of contents for longer documents
- Update documentation with every feature change
- Include troubleshooting sections where appropriate
- Use consistent terminology throughout the project
